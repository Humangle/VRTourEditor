<!DOCTYPE html>
<html>
	<head>
		<script  type="importmap">
			{
				"imports": {
					"three": "https://threejs.org/build/three.module.js",
					"three/addons/" : "https://threejs.org/examples/jsm/"
				}
			}
		</script>
		<script type="module">
			import * as THREE from 'three';
			import {OrbitControls} from 'three/addons/controls/OrbitControls.js';
			import {VRButton} from 'three/addons/webxr/VRButton.js';
			
			let ready = false; //state of the software; do we have all textures/resources ready to render?
			
			let main = (view) => {
			
				//set up the canvas for THREE.js
				const canvas = document.getElementById("c");
				const renderer = new THREE.WebGLRenderer({antialias: true, canvas});
				renderer.setPixelRatio(window.devicePixelRatio);
				renderer.setSize(canvas.clientWidth, canvas.clientHeight);
				renderer.xr.enabled = true;
				renderer.xr.setReferenceSpaceType('local');
				renderer.xr.setFoveation(1.0);
				document.body.appendChild(VRButton.createButton(renderer));
				
				//set the camera up
				const fov = 45;
				const aspect = canvas.clientWidth/canvas.clientHeight;
				const near = 0.1;
				const far = 100;
				const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
				camera.position.set(0, 1.6, 0);
				
				//orbital camera controls
				const controls = new OrbitControls(camera, renderer.domElement);
				controls.enableDamping = true;
				controls.minDistance = 0.001;
				controls.maxDistance = 0.001;
				controls.maxPolarAngle = 2;
				controls.minPolarAngle = 1;
				controls.update();
				
				//here we go!
				const scene = new THREE.Scene();
				scene.background = new THREE.Color(0x010101);
				
				const pickableObjs = new THREE.Object3D();
				
				//button linking to PIC_1
				const button1Geometry = new THREE.SphereGeometry(0.05, 64, 16);
				let button1Mesh = new THREE.Mesh(button1Geometry);
				button1Mesh.name = "PIC_1";
				pickableObjs.add(button1Mesh);
				
				//button linking to PIC_2
				const button2Geometry = new THREE.SphereGeometry(0.05, 64, 16);
				let button2Mesh = new THREE.Mesh(button2Geometry);
				button2Mesh.name = "PIC_2";
				pickableObjs.add(button2Mesh);
				
				//button linking to PIC_3
				const button3Geometry = new THREE.SphereGeometry(0.05, 64, 16);
				let button3Mesh = new THREE.Mesh(button3Geometry);
				button3Mesh.name = "PIC_3";
				pickableObjs.add(button3Mesh);
				
				//youtube logo/link
				const buttontestGeometry = new THREE.SphereGeometry(0.05, 64, 16);
				let buttontestMesh = new THREE.Mesh(buttontestGeometry);
				const ctp = CoordToPosition(0,0,1,0,1.6,0);
				buttontestMesh.position.set(ctp.x, ctp.y, ctp.z);
				console.log(buttontestMesh.position);
				scene.add(buttontestMesh);
				
				scene.add(pickableObjs);
				
				//THE SPHERE
				const radius = 50;
				const widthSegments = 64;
				const heightSegments = 32;
				const sphereGeometry = new THREE.SphereGeometry(radius, widthSegments, heightSegments);
				
				//loading textures
				const loadingElem = document.querySelector('#loading');
				const progressBarElem = loadingElem.querySelector('.progressbar');
				const loadManager = new THREE.LoadingManager();
				const loader = new THREE.TextureLoader(loadManager);
				
				const sphereTexture1 = loader.load(view.PIC_1.img);
				sphereTexture1.colorSpace = THREE.SRGBColorSpace;
				const sphereTexture2 = loader.load(view.PIC_2.img);
				sphereTexture2.colorSpace = THREE.SRGBColorSpace;
				const sphereTexture3 = loader.load(view.PIC_3.img);
				sphereTexture3.colorSpace = THREE.SRGBColorSpace;
				const sphereMaterial = new THREE.MeshBasicMaterial({side: THREE.BackSide, color: 0xFFFFFF, map: sphereTexture1});
				let sphereMesh;
				 
				loadManager.onLoad = () => {
					loadingElem.style.display = 'none';
					sphereMesh = new THREE.Mesh(sphereGeometry, sphereMaterial);
					sphereMesh.name = "sphere";
					sphereMesh.position.set(0,1.6,0);
					sphereMesh.scale.x = -1;//flipping the material back because THREE.Backside means we're looking from behind which means it's flipped
					scene.add(sphereMesh);
					ready = true;
				};
				
				loadManager.onProgress = (urlOfLastItemLoaded, itemsLoaded, itemsTotal) => {
					const progress = itemsLoaded / itemsTotal;
					progressBarElem.style.transform = `scaleX(${progress})`;
				};
				
				//switch to the view of the button selected
				const teleport = (pic) => {
					switch (pic){
						case 'PIC_1':
							//if pic1 link was clicked on
							sphereMaterial.map = sphereTexture1;
							button1Mesh.position.set(view.PIC_1.PIC_1.x, view.PIC_1.PIC_1.y, view.PIC_1.PIC_1.z);
							button1Mesh.visible = false;
							button2Mesh.position.set(view.PIC_1.PIC_2.x, view.PIC_1.PIC_2.y, view.PIC_1.PIC_2.z);
							button2Mesh.visible = true;
							button3Mesh.position.set(view.PIC_1.PIC_3.x, view.PIC_1.PIC_3.y, view.PIC_1.PIC_3.z);
							button3Mesh.visible = true;
							break;
						case 'PIC_2':
							//if pic2 link was clicked on
							sphereMaterial.map = sphereTexture2;
							button1Mesh.position.set(view.PIC_2.PIC_1.x, view.PIC_2.PIC_1.y, view.PIC_2.PIC_1.z);
							button1Mesh.visible = true;
							button2Mesh.position.set(view.PIC_2.PIC_2.x, view.PIC_2.PIC_2.y, view.PIC_2.PIC_2.z);
							button2Mesh.visible = false;
							button3Mesh.position.set(view.PIC_2.PIC_3.x, view.PIC_2.PIC_3.y, view.PIC_2.PIC_3.z);
							button3Mesh.visible = true;
							break;
						case 'PIC_3':
							//if pic3 link was clicked on
							sphereMaterial.map = sphereTexture3;
							button1Mesh.position.set(view.PIC_3.PIC_1.x, view.PIC_3.PIC_1.y, view.PIC_3.PIC_1.z);
							button1Mesh.visible = true;
							button2Mesh.position.set(view.PIC_3.PIC_2.x, view.PIC_3.PIC_2.y, view.PIC_3.PIC_2.z);
							button2Mesh.visible = true;
							button3Mesh.position.set(view.PIC_3.PIC_3.x, view.PIC_3.PIC_3.y, view.PIC_3.PIC_3.z);
							button3Mesh.visible = false;
							break;
						case 'sphere':
							//
							break;
						default:
							//
					}
				}
				
				//switch to the first view
				teleport("PIC_1");
				
				//desktop raycaster
				class MousePickHelper extends THREE.EventDispatcher {
					constructor(scene) {
						super();
						this.raycaster = new THREE.Raycaster();
						this.selectedObject = new THREE.Object3D();
						this.pointer = new THREE.Vector2();
						
						const onPointerUp = (event) => {
							if (this.selectedObject) { 
								this.dispatchEvent({type: event.type, object: this.selectedObject});
							}
						}
						
						//window.addEventListener('pointerdown', onPointerDown);
						window.addEventListener('pointerup', onPointerUp);
					}
					reset(){
						this.selectedObject = new THREE.Object3D;
					}
					update(pickablesParent, time){
						this.reset();
						
						this.raycaster.setFromCamera(this.pointer, camera);

						//objects intersecting the Desktop Raycaster
						const intersections = this.raycaster.intersectObjects(pickablesParent.children);

						for ( let i = 0; i < intersections.length; i ++ ) {
							switch (intersections[ i ].object.name){
								case 'PIC_1':
									this.selectedObject = intersections[i].object;
									intersections[i].object.scale.set(2,1,2);
									break;
								case 'PIC_2':
									this.selectedObject = intersections[i].object;
									intersections[i].object.scale.set(2,1,2);
									break;
								case 'PIC_3':
									this.selectedObject = intersections[i].object;
									intersections[i].object.scale.set(2,1,2);
									break;
							}
						}
					};
				}
				
				//vr raycaster
				class ControllerPickHelper extends THREE.EventDispatcher {
					constructor(scene) {
						super();
						this.raycaster = new THREE.Raycaster();
						this.controllerToObjectMap = new Map();
						this.tempMatrix = new THREE.Matrix4();
				 
						const pointerGeometry = new THREE.BufferGeometry().setFromPoints([
							new THREE.Vector3(0, 0, 0),
							new THREE.Vector3(0, 0, -1),
						]);
				 
						this.controllers = [];
						
						const selectListener = (event) => {
							const controller = event.target;
							const selectedObject = this.controllerToObjectMap.get(event.target);
							if (selectedObject) {
								this.dispatchEvent({type: event.type, controller, object: selectedObject});
							}
						};
						
						for ( let i = 0; i < 2; ++ i ) {

							const controller = renderer.xr.getController( i );
							controller.addEventListener('select', selectListener);
							//controller.addEventListener('selectstart', startListener);
							//controller.addEventListener('selectend', endListener);
							scene.add(controller);

							const line = new THREE.Line(pointerGeometry);
							line.scale.z = 4;
							controller.add(line);
							this.controllers.push({ controller, line });

						}
					}
					reset() {
						this.controllerToObjectMap.clear();
					}
					update(pickablesParent, time) {
						this.reset();
						
						for (const {controller, line} of this.controllers) {
							//cast a ray through the from the controller
							this.tempMatrix.identity().extractRotation(controller.matrixWorld);
							this.raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
							this.raycaster.ray.direction.set(0, 0, -1).applyMatrix4(this.tempMatrix);
							//objects intersecting the VR Raycaster
							const vrintersections = this.raycaster.intersectObjects(pickablesParent.children);
							
							for ( let i = 0; i < vrintersections.length; i++) {
								switch (vrintersections[i].object.name){
									case 'PIC_1':
										this.controllerToObjectMap.set(controller, vrintersections[i].object);
										vrintersections[i].object.scale.set(2,1,2);
										break;
									case 'PIC_2':
										this.controllerToObjectMap.set(controller, vrintersections[i].object);
										vrintersections[i].object.scale.set(2,1,2);
										break;
									case 'PIC_3':
										this.controllerToObjectMap.set(controller, vrintersections[i].object);
										vrintersections[i].object.scale.set(2,1,2);
										break;
									case 'sphere':
										line.scale.z = 4;
										break;
									default:
										line.scale.z = vrintersections[i].distance;
								}
							}
						}
					}
				}
				
				//On Desktop click
				const DesktopPicker = new MousePickHelper(scene);
				DesktopPicker.addEventListener('pointerup', (event) => {
					//switch to the view of the button selected
					teleport(event.object.name);
				});
				
				//On VR click
				const VRPicker = new ControllerPickHelper(scene);
				VRPicker.addEventListener('select', (event) => {
					//switch to the view of the button selected
					teleport(event.object.name);
				});
				
				const onPointerMove = (event) => {
					//calculate pointer position in normalized device coordinates
					//(-1 to +1) for both components
					DesktopPicker.pointer.x = (event.clientX/canvas.clientWidth) * 2 - 1;
					DesktopPicker.pointer.y = - (event.clientY/canvas.clientHeight) * 2 + 1;
				}
				
				const onWindowResize = () => {
					camera.aspect = canvas.clientWidth/canvas.clientHeight;
					camera.updateProjectionMatrix();

					renderer.setSize(canvas.clientWidth, canvas.clientHeight);
				}
			
				let render = (time) => {
					time *= 0.001; //milliseconds to seconds
					
					button1Mesh.scale.set(1,1,1);
					button2Mesh.scale.set(1,1,1);
					button3Mesh.scale.set(1,1,1);
					
					if (ready){
						
						//update the vr raycaster and calculate objects intersecting it
						VRPicker.update(pickableObjs, time);
						
						//update the desktop raycaster and calculate the objects intersecting it
						DesktopPicker.update(pickableObjs, time);
					}
					
					renderer.render(scene, camera);
					
				}
				
				renderer.setAnimationLoop(render);
				window.addEventListener('pointermove', onPointerMove);
				window.addEventListener('resize', onWindowResize);
			}
			
			//picking the texture to render for performance/quality
			const links = {
				"lite": {
					"PIC_1": {
						"img": "https://raw.githubusercontent.com/LearningMike/360images/main/PIC_1-min.jpg",
						"PIC_1": {"x": 0, "y": -1.6, "z": 0},
						"PIC_2": {"x": 0.41042417199080256, "y": -1.6, "z": 1.12763114494309},
						"PIC_3": {"x": -0.261467228242974, "y": -1.6, "z": 2.988584094275237}
					},
					"PIC_2": {
						"img": "https://raw.githubusercontent.com/LearningMike/360images/main/PIC_2-min.jpg",
						"PIC_1": {"x": -0.13073361412148737, "y": -1.6, "z": -1.4942920471376184},
						"PIC_2": {"x": 0, "y": -1.6, "z": 0},
						"PIC_3": {"x": -1.0324375854318826, "y": -1.6, "z": 1.4744736797201856}
					},
					"PIC_3": {
						"img": "https://raw.githubusercontent.com/LearningMike/360images/main/PIC_3-min.jpg",
						"PIC_1": {"x": -1.2678547852220998, "y": -1.6, "z": -2.7189233611099493},
						"PIC_2": {"x": -0.15688033694578485, "y": -1.6, "z": -1.793150456565142},
						"PIC_3": {"x": -1, "y": -1.6, "z": 0}
					}
				},
				"full": {
					"PIC_1": {
						"img": "https://raw.githubusercontent.com/LearningMike/360images/main/PIC_1.jpg",
						"PIC_1": {"x": 0, "y": -1.6, "z": 0},
						"PIC_2": {"x": 0.41042417199080256, "y": -1.6, "z": 1.12763114494309},
						"PIC_3": {"x": -0.2614672282429747, "y": -1.6, "z": 2.988584094275237}
					},
					"PIC_2": {
						"img": "https://raw.githubusercontent.com/LearningMike/360images/main/PIC_2.jpg",
						"PIC_1": {"x": -0.13073361412148737, "y": -1.6, "z": -1.4942920471376184},
						"PIC_2": {"x": 0, "y": -1.6, "z": 0},
						"PIC_3": {"x": -1.0324375854318826, "y": -1.6, "z": 1.4744736797201856}
					},
					"PIC_3": {
						"img": "https://raw.githubusercontent.com/LearningMike/360images/main/PIC_3.jpg",
						"PIC_1": {"x": -1.2678547852220998, "y": -1.6, "z": -2.7189233611099493},
						"PIC_2": {"x": -0.15688033694578485, "y": -1.6, "z": -1.793150456565142},
						"PIC_3": {"x": -1, "y": -1.6, "z": 0}
					}
				}
			};
			
			let version = links.full;
			navigator.xr.isSessionSupported('immersive-vr').then((supported) => {
				if (!supported){
					version = links.lite;
				}
			}).finally(() => {
				main(version);
			});
			
			//i'm only using longitude for this project
			const CoordToPosition = (lat, lon, dep, cx, cy, cz) => {
				let latRad = 0 * Math.PI / 180; //0 replaced lat here only for this project
				let lonRad = lon * Math.PI / 180;

				let xPos= dep * Math.cos(latRad) * Math.cos(lonRad);
				let zPos = dep * Math.cos(latRad) * Math.sin(lonRad);
				let yPos = dep * Math.sin(latRad);
			   
				let localcoord = {"x": xPos, "y": yPos, "z": zPos};
				
				let worldcoord = {"x": localcoord.x+cx, "y": -1.6, "z": localcoord.z+cz};
				return worldcoord;
			}
			
		</script>
		<link rel="stylesheet" href="main.css" />
	</head>
	<body>
		<div id="loading">
			<div class="progress"><div class="progressbar"></div></div>
		</div>
		<canvas id="c">
		</canvas>
	</body>
</html>