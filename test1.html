<html>
	<head>
		<script  type="importmap">
			{
				"imports": {
					"three": "https://threejs.org/build/three.module.js",
					"three/addons/" : "https://threejs.org/examples/jsm/"
				}
			}
		</script>
		<script type="module">
			import * as THREE from 'three';
			import {OrbitControls} from 'three/addons/controls/OrbitControls.js';
			import {VRButton} from 'three/addons/webxr/VRButton.js';
			
			let ready = false; //state of the software
			
			let main = () => {
				//set up the canvas for THREE.js
				const canvas = document.getElementById("c");
				const renderer = new THREE.WebGLRenderer({antialias: true, canvas});
				renderer.setPixelRatio(window.devicePixelRatio);
				renderer.xr.enabled = true;
				document.body.appendChild(VRButton.createButton(renderer));
				
				//set the camera up
				const fov = 60;
				const aspect = 2;
				const near = 0.1;
				const far = 50;
				const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
				camera.position.set(0, 1.6, 0);
				
				//orbital camera controls
				const controls = new OrbitControls(camera, renderer.domElement);
				controls.enableDamping = true;
				controls.minDistance = 0.001;
				controls.maxDistance = 0.001;
				controls.maxPolarAngle = 2;
				controls.minPolarAngle = 1;
				controls.update();
				
				//here we go!
				const scene = new THREE.Scene();
				
				//loading textures
				const loadingElem = document.querySelector('#loading');
				const progressBarElem = loadingElem.querySelector('.progressbar');
				const loadManager = new THREE.LoadingManager();
				const loader = new THREE.TextureLoader(loadManager);
				
				const button1Geometry = new THREE.SphereGeometry(0.1, 16, 16);
				let button1Mesh = new THREE.Mesh(button1Geometry);
				button1Mesh.name = "PIC_1";
				button1Mesh.position.set(0,-1.6,0);
				scene.add(button1Mesh);
				
				const button2Geometry = new THREE.SphereGeometry(0.1, 16, 16);
				let button2Mesh = new THREE.Mesh(button2Geometry);
				button2Mesh.name = "PIC_2";
				button2Mesh.position.set(0,-1.6,1.5);
				scene.add(button2Mesh);
				
				const button3Geometry = new THREE.SphereGeometry(0.1, 16, 16);
				let button3Mesh = new THREE.Mesh(button3Geometry);
				button3Mesh.name = "PIC_3";
				button3Mesh.position.set(0,-1.6,3);
				scene.add(button3Mesh);
				
				const radius = 10;
				const widthSegments = 32;
				const heightSegments = 24;
				const sphereGeometry = new THREE.SphereGeometry(radius, widthSegments, heightSegments);
				
				const sphereTexture1 = loader.load('https://raw.githubusercontent.com/LearningMike/360images/main/PIC_1-min.jpg');
				sphereTexture1.colorSpace = THREE.SRGBColorSpace;
				const sphereTexture2 = loader.load('https://raw.githubusercontent.com/LearningMike/360images/main/PIC_2-min.jpg');
				sphereTexture2.colorSpace = THREE.SRGBColorSpace;
				const sphereTexture3 = loader.load('https://raw.githubusercontent.com/LearningMike/360images/main/PIC_3-min.jpg');
				sphereTexture3.colorSpace = THREE.SRGBColorSpace;
				const sphereMaterial = new THREE.MeshBasicMaterial({side: THREE.BackSide, color: 0xFFFFFF, map: sphereTexture1});
				let sphereMesh;
				 
				loadManager.onLoad = () => {
					loadingElem.style.display = 'none';
					sphereMesh = new THREE.Mesh(sphereGeometry, sphereMaterial);
					sphereMesh.name = "sphere";
					sphereMesh.scale.x = -1;//flipping the material back because THREE.Backside means were looking from behind which means it's flipped
					scene.add(sphereMesh);
					ready = true;
				};
				
				loadManager.onProgress = (urlOfLastItemLoaded, itemsLoaded, itemsTotal) => {
					const progress = itemsLoaded / itemsTotal;
					progressBarElem.style.transform = `scaleX(${progress})`;
				};
				
				const raycaster = new THREE.Raycaster();
				const pointer = new THREE.Vector2();
				let clicking = false;
				function onPointerMove( event ) {
					// calculate pointer position in normalized device coordinates
					// (-1 to +1) for both components
					pointer.x = ( event.clientX / window.innerWidth ) * 2 - 1;
					pointer.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
				}
				
				function onPointerDown (event) {
					clicking = true;
				}
				
				function onPointerUp (event) {
					clicking = false;
				}
			
				let render = (time) => {
					time *= 0.001; // convert time to seconds
					
					if (ready){
						//sphereMesh.rotation.y = time/2;
						
						// update the picking ray with the camera and pointer position
						raycaster.setFromCamera( pointer, camera );

						// calculate objects intersecting the picking ray
						const intersects = raycaster.intersectObjects( scene.children );

						for ( let i = 0; i < intersects.length; i ++ ) {
						
							switch (intersects[ i ].object.name ){
								case 'PIC_1':
										intersects[ i ].object.scale.x = 2;
										button2Mesh.scale.x = 1;
										button3Mesh.scale.x = 1;
									if (clicking){
										//if pic1 link was clicked on
										sphereMaterial.map = sphereTexture1;
										
										button1Mesh.position.set(0, -1.6, 0);
										button1Mesh.scale.set(0,0,0);
										button2Mesh.position.set(0,-1.6,1.5);
										button2Mesh.scale.set(1,1,1);
										button3Mesh.position.set(-0.1,-1.6,3);
										button3Mesh.scale.set(1,1,1);
									}
									break;
								case 'PIC_2':
										intersects[ i ].object.scale.x = 2;
										button1Mesh.scale.x = 1;
										button3Mesh.scale.x = 1;
									if (clicking){
										//if pic2 link was clicked on
										sphereMaterial.map = sphereTexture2;
										
										button1Mesh.position.set(0, -1.6, -1.5);
										button1Mesh.scale.set(1,1,1);
										button2Mesh.position.set(0,-1.6,0);
										button2Mesh.scale.set(0,0,0);
										button3Mesh.position.set(-1,-1.6,1.5);
										button3Mesh.scale.set(1,1,1);
									}
									break;
								case 'PIC_3':
										intersects[ i ].object.scale.x = 2;
										button1Mesh.scale.x = 1;
										button2Mesh.scale.x = 1;
									if (clicking){
										//if pic3 link was clicked on
										sphereMaterial.map = sphereTexture3;
										
										button1Mesh.position.set(-1.5, -1.6, -2.5);
										button1Mesh.scale.set(1,1,1);
										button2Mesh.position.set(-0.2,-1.6,-1.5);
										button2Mesh.scale.set(1,1,1);
										button3Mesh.position.set(-1,-1.6,0);
										button3Mesh.scale.set(0,0,0);
									}
									break;
								case 'sphere':
									clicking = false;
									break;
								default:
									button1Mesh.scale.x = 1;
									button2Mesh.scale.x = 1;
									button3Mesh.scale.x = 1;
							}
						}
					}
					
					renderer.render(scene, camera);
					
				}
				renderer.setAnimationLoop(render);
				window.addEventListener( 'pointermove', onPointerMove );
				window.addEventListener( 'pointerdown', onPointerDown );
				window.addEventListener( 'pointerup', onPointerUp );
			}
			main();
		</script>
		<link rel="stylesheet" href="main.css" />
	</head>
	<body>
		<div id="loading">
			<div class="progress"><div class="progressbar"></div></div>
		</div>
		<canvas id="c" height="600" width="1200">
		</canvas>
	</body>
</html>