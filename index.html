<html>
	<head>
		<script  type="importmap">
			{
				"imports": {
					"three": "https://threejs.org/build/three.module.js",
					"three/addons/" : "https://threejs.org/examples/jsm/"
				}
			}
		</script>
		<script type="module">
			import * as THREE from 'three';
			import {OrbitControls} from 'three/addons/controls/OrbitControls.js';
			import {VRButton} from 'three/addons/webxr/VRButton.js';
			
			let ready = false; //state of the software
			
			let main = () => {
				//set up the canvas for THREE.js
				const canvas = document.getElementById("c");
				const renderer = new THREE.WebGLRenderer({antialias: true, canvas});
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.xr.enabled = true;
				renderer.xr.setReferenceSpaceType( 'local' );
				document.body.appendChild(VRButton.createButton(renderer));
				window.addEventListener( 'resize', onWindowResize );
				
				//set the camera up
				const fov = 70;
				const aspect = 2;
				const near = 1;//was 0.1
				const far = 100;
				const camera = new THREE.PerspectiveCamera(fov, window.innerWidth / window.innerHeight, near, far);
				camera.position.set(0, 1.6, 0);
				
				//orbital camera controls
				const controls = new OrbitControls(camera, renderer.domElement);
				controls.enableDamping = true;
				controls.minDistance = 0.001;
				controls.maxDistance = 0.001;
				controls.maxPolarAngle = 2;
				controls.minPolarAngle = 1;
				controls.update();
				
				//here we go!
				const scene = new THREE.Scene();
				
				const pickableObjs = new THREE.Object3D();
				
				//loading textures
				const loadingElem = document.querySelector('#loading');
				const progressBarElem = loadingElem.querySelector('.progressbar');
				const loadManager = new THREE.LoadingManager();
				const loader = new THREE.TextureLoader(loadManager);
				
				//button linking to PIC_1
				const button1Geometry = new THREE.SphereGeometry(0.1, 16, 16);
				let button1Mesh = new THREE.Mesh(button1Geometry);
				button1Mesh.name = "PIC_1";
				button1Mesh.position.set(0,-1.6,0);
				pickableObjs.add(button1Mesh);
				
				//button linking to PIC_2
				const button2Geometry = new THREE.SphereGeometry(0.1, 16, 16);
				let button2Mesh = new THREE.Mesh(button2Geometry);
				button2Mesh.name = "PIC_2";
				button2Mesh.position.set(0,-1.6,1.5);
				pickableObjs.add(button2Mesh);
				
				//button linking to PIC_3
				const button3Geometry = new THREE.SphereGeometry(0.1, 16, 16);
				let button3Mesh = new THREE.Mesh(button3Geometry);
				button3Mesh.name = "PIC_3";
				button3Mesh.position.set(0,-1.6,3);
				pickableObjs.add(button3Mesh);
				
				scene.add(pickableObjs);
				
				//THE SPHERE
				const radius = 10;
				const widthSegments = 32;
				const heightSegments = 24;
				const sphereGeometry = new THREE.SphereGeometry(radius, widthSegments, heightSegments);
				
				const sphereTexture1 = loader.load('https://raw.githubusercontent.com/LearningMike/360images/main/PIC_1-min.jpg');
				sphereTexture1.colorSpace = THREE.SRGBColorSpace;
				const sphereTexture2 = loader.load('https://raw.githubusercontent.com/LearningMike/360images/main/PIC_2-min.jpg');
				sphereTexture2.colorSpace = THREE.SRGBColorSpace;
				const sphereTexture3 = loader.load('https://raw.githubusercontent.com/LearningMike/360images/main/PIC_3-min.jpg');
				sphereTexture3.colorSpace = THREE.SRGBColorSpace;
				const sphereMaterial = new THREE.MeshBasicMaterial({side: THREE.BackSide, color: 0xFFFFFF, map: sphereTexture1});
				let sphereMesh;
				 
				loadManager.onLoad = () => {
					loadingElem.style.display = 'none';
					sphereMesh = new THREE.Mesh(sphereGeometry, sphereMaterial);
					sphereMesh.name = "sphere";
					sphereMesh.position.set(0,1.6,0);
					sphereMesh.scale.x = -1;//flipping the material back because THREE.Backside means were looking from behind which means it's flipped
					scene.add(sphereMesh);
					ready = true;
				};
				
				loadManager.onProgress = (urlOfLastItemLoaded, itemsLoaded, itemsTotal) => {
					const progress = itemsLoaded / itemsTotal;
					progressBarElem.style.transform = `scaleX(${progress})`;
				};
				
				//desktop raycaster
				const raycaster = new THREE.Raycaster();
				const pointer = new THREE.Vector2();
				let clicking = false;
				
				//vr raycaster
				class ControllerPickHelper extends THREE.EventDispatcher {
					constructor(scene) {
						super();
						this.raycaster = new THREE.Raycaster();
						this.objectToColorMap = new Map();
						this.controllerToObjectMap = new Map();
						this.tempMatrix = new THREE.Matrix4();
				 
						const pointerGeometry = new THREE.BufferGeometry().setFromPoints([
							new THREE.Vector3(0, 0, 0),
							new THREE.Vector3(0, 0, -1),
						]);
				 
						this.controllers = [];
						
						const selectListener = ( event ) => {
							const controller = event.target;
							const selectedObject = this.controllerToObjectMap.get( event.target );
							if ( selectedObject ) {

								this.dispatchEvent( { type: event.type, controller, selectedObject } );

							}
						};
						
						for ( let i = 0; i < 2; ++ i ) {

							const controller = renderer.xr.getController( i );
							controller.addEventListener( 'select', selectListener );
							//controller.addEventListener( 'selectstart', selectListener );
							//controller.addEventListener( 'selectend', endListener );
							scene.add( controller );

							const line = new THREE.Line( pointerGeometry );
							line.scale.z = 100;
							controller.add( line );
							this.controllers.push( { controller, line } );

						}
					}
					reset() {
						// restore the colors
						//this.objectToColorMap.forEach((color, object) => {
							//object.material.emissive.setHex(color);
						//});
						//this.objectToColorMap.clear();
						this.controllerToObjectMap.clear();
					 }
					update(pickablesParent, time) {
						this.reset();
						for (const {controller, line} of this.controllers) {
							// cast a ray through the from the controller
							this.tempMatrix.identity().extractRotation(controller.matrixWorld);
							this.raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
							this.raycaster.ray.direction.set(0, 0, -1).applyMatrix4(this.tempMatrix);
							// get the list of objects the ray intersected
							const vrintersections = this.raycaster.intersectObjects(pickablesParent.children);
							let pickedObject;
							
							for ( let i = 0; i < vrintersections.length; i++) {
								switch (vrintersections[ i ].object.name ){
									case 'PIC_1':
										// save which object this controller picked
										pickedObject = vrintersections[i].object;
										this.controllerToObjectMap.set( controller, pickedObject );
										vrintersections[i].object.scale.set(2,2,2);
										button2Mesh.scale.set(1,1,1);
										button3Mesh.scale.set(1,1,1);
										
										break;
									case 'PIC_2':
										// save which object this controller picked
										pickedObject = vrintersections[i].object;
										this.controllerToObjectMap.set( controller, pickedObject );
										vrintersections[ i ].object.scale.set(2,2,2);
										button1Mesh.scale.set(1,1,1);
										button3Mesh.scale.set(1,1,1);
										
										break;
									case 'PIC_3':
										// save which object this controller picked
										pickedObject = vrintersections[i].object;
										this.controllerToObjectMap.set( controller, pickedObject );
										vrintersections[ i ].object.scale.set(2,2,2);
										button1Mesh.scale.set(1,1,1);
										button2Mesh.scale.set(1,1,1);
										
										break;
									case 'sphere':
										//clicking = false;
										break;
									default:
										button1Mesh.scale.x = 1;
										button2Mesh.scale.x = 1;
										button3Mesh.scale.x = 1;
								}
							}
						}
					}
				}
				
				const controllerToSelection = new Map();
				const pickHelper = new ControllerPickHelper( scene );
				pickHelper.addEventListener( 'select', ( event ) => {
				
					switch (event.selectedObject.name ){
						case 'PIC_1':
							//if pic1 link was clicked on
							sphereMaterial.map = sphereTexture1;
								
							button1Mesh.position.set(0, -1.6, 0);
							button1Mesh.scale.set(0,0,0);
							button2Mesh.position.set(0,-1.6,1.5);
							button2Mesh.scale.set(1,1,1);
							button3Mesh.position.set(-0.1,-1.6,3);
							button3Mesh.scale.set(1,1,1);
							break;
						case 'PIC_2':
							//if pic2 link was clicked on
							sphereMaterial.map = sphereTexture2;
								
							button1Mesh.position.set(0, -1.6, -1.5);
							button1Mesh.scale.set(1,1,1);
							button2Mesh.position.set(0,-1.6,0);
							button2Mesh.scale.set(0,0,0);
							button3Mesh.position.set(-1,-1.6,1.5);
							button3Mesh.scale.set(1,1,1);
							break;
						case 'PIC_3':
							//if pic3 link was clicked on
							sphereMaterial.map = sphereTexture3;
								
							button1Mesh.position.set(-1.5, -1.6, -2.5);
							button1Mesh.scale.set(1,1,1);
							button2Mesh.position.set(-0.2,-1.6,-1.5);
							button2Mesh.scale.set(1,1,1);
							button3Mesh.position.set(-1,-1.6,0);
							button3Mesh.scale.set(0,0,0);
							break;
						case 'sphere':
							clicking = false;
							break;
						default:
							button1Mesh.scale.x = 1;
							button2Mesh.scale.x = 1;
							button3Mesh.scale.x = 1;
					}

				} );
				
				function onPointerMove(event) {
					// calculate pointer position in normalized device coordinates
					// (-1 to +1) for both components
					pointer.x = ( event.clientX / window.innerWidth ) * 2 - 1;
					pointer.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
				}
				
				function onPointerDown (event) {
					clicking = true;
				}
				
				function onPointerUp (event) {
					clicking = false;
				}
				
				function onWindowResize() {

					camera.aspect = window.innerWidth / window.innerHeight;
					camera.updateProjectionMatrix();

					renderer.setSize( window.innerWidth, window.innerHeight );
				}
			
				let render = (time) => {
					time *= 0.001; // convert time to seconds
					
					pickHelper.update(pickableObjs, time);
					
					if (ready){
						//sphereMesh.rotation.y = time/2;
						
						// update the picking ray with the camera and pointer position
						raycaster.setFromCamera( pointer, camera );

						// calculate objects intersecting the picking ray
						const intersects = raycaster.intersectObjects( scene.children );

						for ( let i = 0; i < intersects.length; i ++ ) {
						
							switch (intersects[ i ].object.name ){
								case 'PIC_1':
										intersects[ i ].object.scale.x = 2;
										button2Mesh.scale.x = 1;
										button3Mesh.scale.x = 1;
									if (clicking){
										//if pic1 link was clicked on
										sphereMaterial.map = sphereTexture1;
										
										button1Mesh.position.set(0, -1.6, 0);
										button1Mesh.scale.set(0,0,0);
										button2Mesh.position.set(0,-1.6,1.5);
										button2Mesh.scale.set(1,1,1);
										button3Mesh.position.set(-0.1,-1.6,3);
										button3Mesh.scale.set(1,1,1);
									}
									break;
								case 'PIC_2':
										intersects[ i ].object.scale.x = 2;
										button1Mesh.scale.x = 1;
										button3Mesh.scale.x = 1;
									if (clicking){
										//if pic2 link was clicked on
										sphereMaterial.map = sphereTexture2;
										
										button1Mesh.position.set(0, -1.6, -1.5);
										button1Mesh.scale.set(1,1,1);
										button2Mesh.position.set(0,-1.6,0);
										button2Mesh.scale.set(0,0,0);
										button3Mesh.position.set(-1,-1.6,1.5);
										button3Mesh.scale.set(1,1,1);
									}
									break;
								case 'PIC_3':
										intersects[ i ].object.scale.x = 2;
										button1Mesh.scale.x = 1;
										button2Mesh.scale.x = 1;
									if (clicking){
										//if pic3 link was clicked on
										sphereMaterial.map = sphereTexture3;
										
										button1Mesh.position.set(-1.5, -1.6, -2.5);
										button1Mesh.scale.set(1,1,1);
										button2Mesh.position.set(-0.2,-1.6,-1.5);
										button2Mesh.scale.set(1,1,1);
										button3Mesh.position.set(-1,-1.6,0);
										button3Mesh.scale.set(0,0,0);
									}
									break;
								case 'sphere':
									clicking = false;
									break;
								default:
									button1Mesh.scale.x = 1;
									button2Mesh.scale.x = 1;
									button3Mesh.scale.x = 1;
							}
						}
					}
					
					renderer.render(scene, camera);
					
				}
				renderer.setAnimationLoop(render);
				window.addEventListener( 'pointermove', onPointerMove );
				window.addEventListener( 'pointerdown', onPointerDown );
				window.addEventListener( 'pointerup', onPointerUp );
			}
			main();
		</script>
		<link rel="stylesheet" href="main.css" />
	</head>
	<body>
		<div id="loading">
			<div class="progress"><div class="progressbar"></div></div>
		</div>
		<canvas id="c">
		</canvas>
		<a href="worlddata.html">Other Link</a>
	</body>
</html>