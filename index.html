<html>
	<head>
		<script  type="importmap">
			{
				"imports": {
					"three": "https://threejs.org/build/three.module.js",
					"three/addons/" : "https://threejs.org/examples/jsm/"
				}
			}
		</script>
		<script type="module">
			import * as THREE from 'three';
			import {OrbitControls} from 'three/addons/controls/OrbitControls.js';
			import {VRButton} from 'three/addons/webxr/VRButton.js';
			
			let ready = false; //state of the software; do we have all textures/resources ready to render?
			
			let main = () => {
			
				//set up the canvas for THREE.js
				const canvas = document.getElementById("c");
				const renderer = new THREE.WebGLRenderer({antialias: true, canvas});
				renderer.setPixelRatio(window.devicePixelRatio);
				renderer.setSize(window.innerWidth, window.innerHeight);
				renderer.xr.enabled = true;
				renderer.xr.setReferenceSpaceType('local');
				document.body.appendChild(VRButton.createButton(renderer));
				
				//set the camera up
				const fov = 45;
				const aspect = window.innerWidth/window.innerHeight;
				const near = 0.1;
				const far = 100;
				const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
				camera.position.set(0, 1.6, 0);
				
				//orbital camera controls
				const controls = new OrbitControls(camera, renderer.domElement);
				controls.enableDamping = true;
				controls.minDistance = 0.001;
				controls.maxDistance = 0.001;
				controls.maxPolarAngle = 2;
				controls.minPolarAngle = 1;
				controls.update();
				
				//here we go!
				const scene = new THREE.Scene();
				
				const pickableObjs = new THREE.Object3D();
				
				//button linking to PIC_1
				const button1Geometry = new THREE.SphereGeometry(0.1, 16, 16);
				let button1Mesh = new THREE.Mesh(button1Geometry);
				button1Mesh.name = "PIC_1";
				button1Mesh.position.set(0,-1.6,0);
				pickableObjs.add(button1Mesh);
				
				//button linking to PIC_2
				const button2Geometry = new THREE.SphereGeometry(0.1, 16, 16);
				let button2Mesh = new THREE.Mesh(button2Geometry);
				button2Mesh.name = "PIC_2";
				button2Mesh.position.set(0,-1.6,1.5);
				pickableObjs.add(button2Mesh);
				
				//button linking to PIC_3
				const button3Geometry = new THREE.SphereGeometry(0.1, 16, 16);
				let button3Mesh = new THREE.Mesh(button3Geometry);
				button3Mesh.name = "PIC_3";
				button3Mesh.position.set(0,-1.6,3);
				pickableObjs.add(button3Mesh);
				
				scene.add(pickableObjs);
				
				//THE SPHERE
				const radius = 10;
				const widthSegments = 32;
				const heightSegments = 24;
				const sphereGeometry = new THREE.SphereGeometry(radius, widthSegments, heightSegments);
				
				//loading textures
				const loadingElem = document.querySelector('#loading');
				const progressBarElem = loadingElem.querySelector('.progressbar');
				const loadManager = new THREE.LoadingManager();
				const loader = new THREE.TextureLoader(loadManager);
				
				const sphereTexture1 = loader.load('https://raw.githubusercontent.com/LearningMike/360images/main/PIC_1-min.jpg');
				sphereTexture1.colorSpace = THREE.SRGBColorSpace;
				const sphereTexture2 = loader.load('https://raw.githubusercontent.com/LearningMike/360images/main/PIC_2-min.jpg');
				sphereTexture2.colorSpace = THREE.SRGBColorSpace;
				const sphereTexture3 = loader.load('https://raw.githubusercontent.com/LearningMike/360images/main/PIC_3-min.jpg');
				sphereTexture3.colorSpace = THREE.SRGBColorSpace;
				const sphereMaterial = new THREE.MeshBasicMaterial({side: THREE.BackSide, color: 0xFFFFFF, map: sphereTexture1});
				let sphereMesh;
				 
				loadManager.onLoad = () => {
					loadingElem.style.display = 'none';
					sphereMesh = new THREE.Mesh(sphereGeometry, sphereMaterial);
					sphereMesh.name = "sphere";
					sphereMesh.position.set(0,1.6,0);
					sphereMesh.scale.x = -1;//flipping the material back because THREE.Backside means we're looking from behind which means it's flipped
					scene.add(sphereMesh);
					ready = true;
				};
				
				loadManager.onProgress = (urlOfLastItemLoaded, itemsLoaded, itemsTotal) => {
					const progress = itemsLoaded / itemsTotal;
					progressBarElem.style.transform = `scaleX(${progress})`;
				};
				
				//desktop raycaster
				class MousePickHelper extends THREE.EventDispatcher {
					constructor(scene) {
						super();
						this.raycaster = new THREE.Raycaster();
						this.selectedObject = new THREE.Object3D();
						this.pointer = new THREE.Vector2();
						
						const onPointerUp = (event) => {
							if (this.selectedObject) { 
								this.dispatchEvent({type: event.type, object: this.selectedObject});
							}
						}
						
						//window.addEventListener('pointerdown', onPointerDown);
						window.addEventListener('pointerup', onPointerUp);
					}
					reset(){
						this.selectedObject = new THREE.Object3D;
					}
					update(pickablesParent, time){
						this.reset();
						
						this.raycaster.setFromCamera(this.pointer, camera);

						//objects intersecting the Desktop Raycaster
						const intersections = this.raycaster.intersectObjects(pickablesParent.children);

						for ( let i = 0; i < intersections.length; i ++ ) {
						
							switch (intersections[ i ].object.name ){
								case 'PIC_1':
									this.selectedObject = intersections[i].object;
									intersections[i].object.scale.set(2,1,2);
									button2Mesh.scale.set(1,1,1);
									button3Mesh.scale.set(1,1,1);
									break;
								case 'PIC_2':
									this.selectedObject = intersections[i].object;
									intersections[i].object.scale.set(2,1,2);
									button1Mesh.scale.set(1,1,1);
									button3Mesh.scale.set(1,1,1);
									break;
								case 'PIC_3':
									this.selectedObject = intersections[i].object;
									intersections[i].object.scale.set(2,1,2);
									button1Mesh.scale.set(1,1,1);
									button2Mesh.scale.set(1,1,1);
									break;
							}
						}
					};
				}
				
				//vr raycaster
				class ControllerPickHelper extends THREE.EventDispatcher {
					constructor(scene) {
						super();
						this.raycaster = new THREE.Raycaster();
						this.controllerToObjectMap = new Map();
						this.tempMatrix = new THREE.Matrix4();
				 
						const pointerGeometry = new THREE.BufferGeometry().setFromPoints([
							new THREE.Vector3(0, 0, 0),
							new THREE.Vector3(0, 0, -1),
						]);
				 
						this.controllers = [];
						
						const selectListener = (event) => {
							const controller = event.target;
							const selectedObject = this.controllerToObjectMap.get(event.target);
							if (selectedObject) {
								this.dispatchEvent({type: event.type, controller, object: selectedObject});
							}
						};
						
						for ( let i = 0; i < 2; ++ i ) {

							const controller = renderer.xr.getController( i );
							controller.addEventListener('select', selectListener);
							//controller.addEventListener('selectstart', startListener);
							//controller.addEventListener('selectend', endListener);
							scene.add(controller);

							const line = new THREE.Line(pointerGeometry);
							line.scale.z = 100;
							controller.add(line);
							this.controllers.push({ controller, line });

						}
					}
					reset() {
						this.controllerToObjectMap.clear();
					}
					update(pickablesParent, time) {
						this.reset();
						
						for (const {controller, line} of this.controllers) {
							//cast a ray through the from the controller
							this.tempMatrix.identity().extractRotation(controller.matrixWorld);
							this.raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
							this.raycaster.ray.direction.set(0, 0, -1).applyMatrix4(this.tempMatrix);
							//objects intersecting the VR Raycaster
							const vrintersections = this.raycaster.intersectObjects(pickablesParent.children);
							
							for ( let i = 0; i < vrintersections.length; i++) {
								switch (vrintersections[i].object.name ){
									case 'PIC_1':
										this.controllerToObjectMap.set(controller, vrintersections[i].object);
										vrintersections[i].object.scale.set(2,1,2);
										button2Mesh.scale.set(1,1,1);
										button3Mesh.scale.set(1,1,1);
										break;
									case 'PIC_2':
										this.controllerToObjectMap.set(controller, vrintersections[i].object);
										vrintersections[i].object.scale.set(2,1,2);
										button1Mesh.scale.set(1,1,1);
										button3Mesh.scale.set(1,1,1);
										break;
									case 'PIC_3':
										this.controllerToObjectMap.set(controller, vrintersections[i].object);
										vrintersections[i].object.scale.set(2,1,2);
										button1Mesh.scale.set(1,1,1);
										button2Mesh.scale.set(1,1,1);
										break;
									case 'sphere':
										//
										break;
									default:
										//
								}
							}
						}
					}
				}
				
				const DesktopPicker = new MousePickHelper(scene);
				DesktopPicker.addEventListener('pointerup', (event) => {
					switch (event.object.name){
						case 'PIC_1':
							//if pic1 link was clicked on
							sphereMaterial.map = sphereTexture1;
								
							button1Mesh.position.set(0, -1.6, 0);
							button1Mesh.scale.set(0,0,0);
							button2Mesh.position.set(0,-1.6,1.5);
							button2Mesh.scale.set(1,1,1);
							button3Mesh.position.set(-0.1,-1.6,3);
							button3Mesh.scale.set(1,1,1);
							break;
						case 'PIC_2':
							//if pic2 link was clicked on
							sphereMaterial.map = sphereTexture2;
								
							button1Mesh.position.set(0, -1.6, -1.5);
							button1Mesh.scale.set(1,1,1);
							button2Mesh.position.set(0,-1.6,0);
							button2Mesh.scale.set(0,0,0);
							button3Mesh.position.set(-1,-1.6,1.5);
							button3Mesh.scale.set(1,1,1);
							break;
						case 'PIC_3':
							//if pic3 link was clicked on
							sphereMaterial.map = sphereTexture3;
								
							button1Mesh.position.set(-1.5, -1.6, -2.5);
							button1Mesh.scale.set(1,1,1);
							button2Mesh.position.set(-0.2,-1.6,-1.5);
							button2Mesh.scale.set(1,1,1);
							button3Mesh.position.set(-1,-1.6,0);
							button3Mesh.scale.set(0,0,0);
							break;
						case 'sphere':
							//
							break;
						default:
							//
					}
				});
				
				const VRPicker = new ControllerPickHelper(scene);
				VRPicker.addEventListener('select', (event) => {
				
					switch (event.object.name){
						case 'PIC_1':
							//if pic1 link was clicked on
							sphereMaterial.map = sphereTexture1;
								
							button1Mesh.position.set(0, -1.6, 0);
							button1Mesh.scale.set(0,0,0);
							button2Mesh.position.set(0,-1.6,1.5);
							button2Mesh.scale.set(1,1,1);
							button3Mesh.position.set(-0.1,-1.6,3);
							button3Mesh.scale.set(1,1,1);
							break;
						case 'PIC_2':
							//if pic2 link was clicked on
							sphereMaterial.map = sphereTexture2;
								
							button1Mesh.position.set(0, -1.6, -1.5);
							button1Mesh.scale.set(1,1,1);
							button2Mesh.position.set(0,-1.6,0);
							button2Mesh.scale.set(0,0,0);
							button3Mesh.position.set(-1,-1.6,1.5);
							button3Mesh.scale.set(1,1,1);
							break;
						case 'PIC_3':
							//if pic3 link was clicked on
							sphereMaterial.map = sphereTexture3;
								
							button1Mesh.position.set(-1.5, -1.6, -2.5);
							button1Mesh.scale.set(1,1,1);
							button2Mesh.position.set(-0.2,-1.6,-1.5);
							button2Mesh.scale.set(1,1,1);
							button3Mesh.position.set(-1,-1.6,0);
							button3Mesh.scale.set(0,0,0);
							break;
						case 'sphere':
							//
							break;
						default:
							//
					}

				});
				
				const onPointerMove = (event) => {
					//calculate pointer position in normalized device coordinates
					//(-1 to +1) for both components
					DesktopPicker.pointer.x = (event.clientX/window.innerWidth) * 2 - 1;
					DesktopPicker.pointer.y = - (event.clientY/window.innerHeight) * 2 + 1;
				}
				
				const onWindowResize = () => {
					camera.aspect = window.innerWidth/window.innerHeight;
					camera.updateProjectionMatrix();

					renderer.setSize(window.innerWidth, window.innerHeight);
				}
			
				let render = (time) => {
					time *= 0.001; //milliseconds to seconds
					
					/*
					button2Mesh.scale.set(1,1,1);
					button2Mesh.scale.set(1,1,1);
					button3Mesh.scale.set(1,1,1);
					*/
					
					if (ready){
						
						//update the vr raycaster and calculate objects intersecting it
						VRPicker.update(pickableObjs, time);
						
						//update the desktop raycaster and calculate the objects intersecting it
						DesktopPicker.update(pickableObjs, time);
					}
					
					renderer.render(scene, camera);
					
				}
				
				renderer.setAnimationLoop(render);
				window.addEventListener('pointermove', onPointerMove);
				window.addEventListener('resize', onWindowResize);
			}
			main();
		</script>
		<link rel="stylesheet" href="main.css" />
	</head>
	<body>
		<div id="loading">
			<div class="progress"><div class="progressbar"></div></div>
		</div>
		<canvas id="c">
		</canvas>
		<a href="worlddata.html">Other Link</a>
	</body>
</html>