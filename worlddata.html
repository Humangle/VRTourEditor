<!DOCTYPE html>
<html>
	<head>
		<script  type="importmap">
			{
				"imports": {
					"three": "https://threejs.org/build/three.module.js",
					"three/addons/" : "https://threejs.org/examples/jsm/"
				}
			}
		</script>
		<script type="module">
			import * as THREE from 'three';
			import {OrbitControls} from 'three/addons/controls/OrbitControls.js';
			import {ARButton} from 'three/addons/webxr/ARButton.js';
			import {XREstimatedLight} from 'three/addons/webxr/XREstimatedLight.js';
			
			let ready = false; //state of the software
			
			const CoordToPosition = (lat, lon, crad, cx, cy, cz) => {
				let latitude_rad = lat * Math.PI / 180;
				let longitude_rad = lon * Math.PI / 180;

				let xPos= crad * Math.cos(latitude_rad) * Math.cos(longitude_rad);
				let zPos = crad * Math.cos(latitude_rad) * Math.sin(longitude_rad);
				let yPos = crad * Math.sin(latitude_rad);
			   
				let localcoord = {"x": xPos, "y": yPos, "z": zPos};
				
				let worldcoord = {"x": localcoord.x+cx, "y": localcoord.y, "z": localcoord.z+cz};
				return worldcoord;
			}
			
			const loadFile = async (url) => {
				const res = await fetch(url);
				return res.text();
			}
			
			const parseData = (text) => {
				const data = [];
				const settings = {data};
				let max;
				let min;
				
				// split into lines
				text.split('\n').forEach((line) => {
				
					// split the line by whitespace
					const parts = line.trim().split(/\s+/);
					
					if (parts.length === 2) {
					
						// only 2 parts, must be a key/value pair
						settings[parts[0]] = parseFloat(parts[1]);
						
					} else if (parts.length > 2) {
					
						// more than 2 parts, must be data
						const values = parts.map((v) => {
							const value = parseFloat(v);
							if (value === settings.NODATA_value) {
								return undefined;
							}
							max = Math.max(max === undefined ? value : max, value);
							min = Math.min(min === undefined ? value : min, value);
							return value;
						});
						data.push(values);
					}
				});
				return Object.assign(settings, {min, max});
			
			}
			
			//loadFile('https://threejs.org/manual/examples/resources/data/gpw/gpw_v4_basic_demographic_characteristics_rev10_a000_014mt_2010_cntm_1_deg.asc').then(parseData).then(drawData);
			
			let main = () => {
				//set up the canvas for THREE.js
				const canvas = document.getElementById("c");
				const renderer = new THREE.WebGLRenderer({canvas, alpha: true, premultipliedAlpha: false});
				renderer.setPixelRatio(window.devicePixelRatio);
				renderer.setSize(canvas.clientWidth, canvas.clientHeight);
				renderer.xr.enabled = true;
				renderer.xr.setReferenceSpaceType('local');
				renderer.xr.setFoveation(1.0);
				
				//set the camera up
				const fov = 45;
				const aspect = canvas.clientWidth/canvas.clientHeight;
				const near = 0.1;
				const far = 100;
				const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
				camera.position.set(0, 1.6, 0);
				
				//orbital camera controls
				const controls = new OrbitControls(camera, renderer.domElement);
				controls.enableDamping = true;
				controls.minDistance = 0.3;
				controls.maxDistance = 0.6;
				controls.maxPolarAngle = 2;
				controls.minPolarAngle = 1;
				controls.target.set(0, -0.4, -0.5);
				controls.update();
				
				//here we go!
				const scene = new THREE.Scene();
				
				//loading textures
				const loadingElem = document.querySelector('#loading');
				const progressBarElem = loadingElem.querySelector('.progressbar');
				const loadManager = new THREE.LoadingManager();
				const loader = new THREE.TextureLoader(loadManager);
				
				const radius = 0.2;
				const widthSegments = 32;
				const heightSegments = 24;
				const sphereGeometry = new THREE.SphereGeometry(radius, widthSegments, heightSegments);
				
				const EarthDayTexture = loader.load('https://raw.githubusercontent.com/LearningMike/360images/main/8k_earth_daymap.jpg');
				const EarthNightTexture = loader.load('https://raw.githubusercontent.com/LearningMike/360images/main/8k_earth_nightmap.jpg');
				const EarthPopulationTexture = loader.load('https://raw.githubusercontent.com/LearningMike/360images/main/8k_popdensity.jpg');
				const EarthWaterTexture = loader.load('https://raw.githubusercontent.com/LearningMike/360images/main/8k_waterarea.jpg');
				const EarthSpecularTexture = loader.load('https://raw.githubusercontent.com/LearningMike/360images/main/2k_earth_specular_map.tif');
				renderer.initTexture(EarthDayTexture);
				renderer.initTexture(EarthNightTexture);
				renderer.initTexture(EarthPopulationTexture);
				renderer.initTexture(EarthWaterTexture);
				renderer.initTexture(EarthSpecularTexture);
				
				const sphereMaterialEarth = new THREE.MeshStandardMaterial({
					color: 0xFFFFFF,
					map: EarthDayTexture,
					emissive: 0xFFFFFF,
					emissiveMap: EarthNightTexture,
					emissiveIntensity: 0,
					specularMap: EarthSpecularTexture,
					toneMapped: false
				});
					
				let sphereMesh;
				 
				loadManager.onLoad = () => {
					loadingElem.style.display = 'none';
					sphereMesh = new THREE.Mesh(sphereGeometry, sphereMaterialEarth);
					sphereMesh.position.set(0, -0.4, -0.5);
					scene.add(sphereMesh);
					ready = true;
				};
				
				loadManager.onProgress = (urlOfLastItemLoaded, itemsLoaded, itemsTotal) => {
					const progress = itemsLoaded / itemsTotal;
					progressBarElem.style.transform = `scaleX(${progress})`;
				};
				
				const desktoplight = new THREE.DirectionalLight(0xFFFFFF, 2);
				desktoplight.position.set(0, 1.2, 4);
				camera.add(desktoplight);
				scene.add(camera);
				// Don't add the XREstimatedLight to the scene initially.
				// It doesn't have any estimated lighting values until an AR session starts.
				const xrLight = new XREstimatedLight(renderer);
				
				xrLight.addEventListener( 'estimationstart' , () => {

					camera.remove(desktoplight);
					scene.add(xrLight);

					if (xrLight.environment) {

						scene.environment = xrLight.environment;

					}

				} );

				xrLight.addEventListener( 'estimationend', () => {

					scene.remove(xrLight);
					scene.environment = null;
					
					camera.add(desktoplight);

				} );

				document.body.appendChild(ARButton.createButton(renderer, {
					optionalFeatures: ['light-estimation']
				}));
				
				const onWindowResize = () => {
					camera.aspect = canvas.clientWidth/canvas.clientHeight;
					camera.updateProjectionMatrix();

					renderer.setSize(canvas.clientWidth, canvas.clientHeight);
				}
				
				const electricity = (show) => {
					if (show){
						sphereMaterialEarth.emissiveMap = EarthNightTexture;
						sphereMaterialEarth.emissiveIntensity += 0.01;
						if ((desktoplight.intensity - 0.015) > 0) {
							desktoplight.intensity -= 0.015;
						}
					} else {
						sphereMaterialEarth.emissiveIntensity -= 0.02;
						if ((desktoplight.intensity + 0.03) > 0) {
							desktoplight.intensity += 0.03;
						}
					}
				}
				
				const population = (show) => {
					if (show){
						sphereMaterialEarth.emissiveMap = EarthPopulationTexture;
						sphereMaterialEarth.emissiveIntensity += 0.01;
						if ((desktoplight.intensity - 0.015) > 0) {
							desktoplight.intensity -= 0.015;
						}
					} else {
						sphereMaterialEarth.emissiveIntensity -= 0.02;
						if ((desktoplight.intensity + 0.03) > 0) {
							desktoplight.intensity += 0.03;
						}
					}
				}
				
				let render = (time) => {
					time *= 0.001; // convert time to seconds
					
					if (ready){
						//sphereMesh.rotation.y = time/2;
					}
					
					if (time > 5 && time < 8){
						electricity(true);
					} else if (time > 8 && time < 11){
						electricity(false);
					}
					
					if (time > 11 && time < 14){
						population(true);
					}
					
					renderer.render(scene, camera);
					
				}
				renderer.setAnimationLoop(render);
				window.addEventListener('resize', onWindowResize);
			}
			main();
			
			
		</script>
		<link rel="stylesheet" href="main.css" />
	</head>
	<body>
		<div id="loading">
			<div class="progress"><div class="progressbar"></div></div>
		</div>
		<canvas id="c">
		</canvas>
	</body>
</html>